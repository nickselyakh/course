\chapter{Численные эксперименты}\label{chap2}

В настоящей главе исследуется применения параметрического программирования в задаче синтеза оптимальной линейной системы и MPC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Применение параметрического программирования в MPC}\label{2sec:parametric-programming-mpc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Для реализации решения задачи используется MPT3 Toolbox для Matlab, описанный в главе выше.

Первоначально нужно задать все начальные значения, чтобы передать их в $mpt constructMatrices$.
$Mpt constructMatrices$ представляет собой функцию, на вход которой приходят параметры $probStruc$t и $sysStruct$.
sysStruct будет состоять из матриц A, B, C, D, ограничений на $x$ ($x_min$ и $x_max$) и ограничений на $u$ ($u_min$ и $u_max$).
$probStruct$ в свою очередь будет состоять из нормы (norm), числа N, также Q,$P_n$,R и тд.

В качестве примера рассмотрим задачу со следующим критерием качества, который нужно минимизировать:
$$J(u) = \int_0^{t_f}|u(t)|dt \to \min,$$
на траекториях: 
$$
\dot{x} = Ax + Bu
$$
Матрица А будет иметь следующий вид:
$$
A = \begin{bmatrix}
    0 & 1\\
    -1 & 0
\end{bmatrix}
$$

Начальным параметрам присвоим значения: $N = 20, t_0 = 0, t_f = 10$.
Вектор $B$ будет иметь вид: $B = \begin{bmatrix}
    0\\
    1
\end{bmatrix}$

Чтобы отобразить полную структуру нашей задачи в Matlab поступим так, как показано ниже:

\begin{verbatim}
sys = ss(A, B, [], []);

sysd = c2d(sys,tf/N,'zoh');
Ad = sysd.A;
Bd = sysd.B;

sysStruct.A= Ad;
sysStruct.B= Bd;
sysStruct.C= [0 0];
sysStruct.D= 0;

sysStruct.xmin = [-10; -10];
sysStruct.xmax = [10; 10];

sysStruct.umin = -1;
sysStruct.umax = 1;

nx = size(A, 2); 
probStruct.norm=inf;
probStruct.Q=[0 0; 0 0];
probStruct.P_N=[0 0; 0 0];
probStruct.R=1;
probStruct.N=N;
probStruct.subopt_lev=0;
H = [eye(nx); -eye(nx)];
K = eps*ones(nx*2,1);
probStruct.Tconstraint=2;
probStruct.Tset = polytope(H, K);
\end{verbatim}
После этого мы будем иметь все начальные значения для нашей задачи сгенерированную структуру, которую можно решить, используя известные процедуры.
Далее нужно на основании $mpt constructMatrices$ посмотрить класс Opt, который инкапсулирует информацию и решения для задач LP/QP/pLP/pQP/LCP/pLCP.
Для конкретного момента времени высчитаывается u на основании заданного $x_\tau$ и подается на систему. Затем на каждом отрезке из T пересчитвается заданное $x_\tau$.
Мы будем проедлывать описанную выше операцию в цикле на каждом шаге и на половине пути добавим возмущение $w$.
\begin{verbatim}
for tau = 0:NN-1
    probStruct.N=N;
    Matrices = mpt_constructMatrices(sysStruct,probStruct);
    plp = Opt(Matrices);
    solution = plp.solve();
    u = solution.xopt.feval(xtau, 'primal');
    if N > NN/2
        xtau = Ad * xtau + Bd * u(1) + w;
    else
        xtau = Ad * xtau + Bd * u(1);
    end
    
    figure;
    solution.xopt.fplot('obj');
    xlabel('x0');
    ylabel('J(x0)');
    N = N-1;
    X = [X xtau];
    U = [U u(1)];
end
\end{verbatim}
\bigskip


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Результаты}\label{2sec:results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Далее проилюстриуем наглядно полученные результаты на каждом 5 шаге\\ 

N = 20
\includegraphics[width=0.8\textwidth]{figure1.eps}\\
N = 15
\includegraphics[width=0.8\textwidth]{figure5.eps}\\
N = 10
\includegraphics[width=0.8\textwidth]{figure10.eps}\\
N = 5
% \includegraphics[width=0.8\textwidth]{figure15.eps}\\
N = 1
\includegraphics[width=0.8\textwidth]{figure20.eps}\\
X и U
\includegraphics[width=0.8\textwidth]{graphics.eps}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Применение параметрического программирования в задаче синтеза оптимальной линейной системы}\label{2sec:parametric-programming-mpc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ранее была рассмотрена теоретическая база по построению классической оптимальной обратной связи. В данной главе проилюстриуем, как параметрическое программирование применяется в задачах синтеза оптимальной линейной системы.

Рассмотрим следующую задачу:
\begin{equation}
    \begin{aligned}        
    & x_1(t_f) \to \min,\\
    & x_2(t_f) = 0,\\
    \text{на траекториях системы второго порядка}\\
    \begin{cases}
        \dot{x_1} = x_2,\\
        \dot{x_2} = -x_1 + u,
    \end{cases}
    & x_1(t_0) = x_{10},
    & x_2(t_0) = x_{20}
\end{aligned}
\end{equation}
с ограничениями $-L \le u \le L, \ t \in T = [t_0,\ t_f]$
\\
Матрица A имеет вид:
$$
A = \begin{bmatrix}
    0 & 1\\
    -1 & 0
\end{bmatrix}
$$
Вектром $b$ выглядит следующим образом:
$$
b = \begin{bmatrix}
    0 \\
    1
\end{bmatrix}
$$
Матрица $H$:
$$
H = \begin{bmatrix}
    0 \\
    1
\end{bmatrix}
$$

Параметрам задачи присвоим значения: $t_0 = 0,\ t_f = 10$.
Будем использовать дискретные управляющие воздействия с шагом $h = \frac{t_f - t_0}{100}$.
Остальные параметры в программе зададим таким образом:

$c_h, d_h$ на каждом шаге в matlab вычисляется процедурой integral в Matlab, которое высчитывается в цикле для каждого шага:

\begin{verbatim}
for i = 1:N
    ch(i) = integral(C,t0+h*(i-1),t0+h*i,'ArrayValued',true);
    dh(i) = integral(d,t0+h*(i-1),t0+h*i,'ArrayValued',true);
end
\end{verbatim}

$u_0$, в свою очередь, вычисляется с помощью процедуры linprog:
\begin{verbatim}
u0 = linprog(-ch',[],[],dh,g0,-L*ones(N,1),L*ones(N,1))
\end{verbatim}

Далее рассчитаем $x$:
\begin{verbatim}
x = zeros(2,N+1);
x(:,1) = x0;
for i = 1:N
    x(:,i+1) = F(h)*x(:,i)+integral(@(t)u0(i)*F(t0+(i+1)*h-t)*b,t0+i*h,t0+(i+1)*h,'ArrayValued',true);
end
x1 = zeros(2,N+1);
x1(:,1) = x0;
for i = 1:N
    x1(:,i+1) = F(h)*x1(:,i)+integral(@(t)u0(i)*F(t0+(i+1)*h-t)*b+w(t),t0+i*h,t0+(i+1)*h,'ArrayValued',true);
end
\end{verbatim}


Затем на определенном промежутке времени добавим возмущение $w$ и придет к ответу с помощью известных уже нам процедур:
\begin{verbatim}
    for j = 1:N
        j
        if j>90
            w = @(t)0*cos(3*t);
        end
        tau = t0 + (j-1)*h;
        g0 = g-H*F(tf-tau)*x2(:,j);
        u1 = linprog(-ch(j:N),[],[],dh(j:N),g0,-L*ones(N-j+1,1),L*ones(N-j+1,1))
        u2(j) = u1(1);
            
        x2(:,j+1) = F(h)*x2(:,j)+integral(@(t)u2(j)*F(t0+(j+1)*h-t)*b+w(t),t0+j*h,t0+(j+1)*h,'ArrayValued',true);
        x(:,j+1)
        x2(:,j+1)
    end
\end{verbatim}

